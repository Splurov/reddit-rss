#!/usr/bin/env node
"use strict";

// Auto generates the endpoints from the Reddit API.
// Recommend running tests after running this to make sure things are
// still the same & we haven't missed any updates

var path = require('path')
, when = require('when')
, mu = require('mu2')
, request = require('request')
, cheerio = require('cheerio');

function getEndpointOauth($, endpoint) {
	var $oauthList = $(endpoint).find('.oauth-scope-list');

	var oauth = $oauthList.length === 0
		? []
		: $oauthList.toArray().map(function(e) { return $(e).text(); });

	return oauth;
}


function getEndpointExtensions($, endpoint) {
	var $exts = $('.extensions', $(endpoint));

	var extensions = $exts.length === 0
		? []
		: $exts.text().replace(/[^\w\. ]/g, '').trim().split(/ +/);

	return extensions;
}

function getEndpointUrl(method, path, hasOauth) {
	var url = {};

	if (hasOauth) {
		url.oauth = 'https://oauth.reddit.com' + path;
	} 

	url.standard = (method === 'GET'
		? 'http://www.reddit.com'
		: 'https://ssl.reddit.com') + path;

	return url;
}

function getEndpointDescription($, endpoint) {
	return $('.md', $(endpoint)).text().replace(/\n$/, '');
}

function getEndpointArgs($, endpoint) {
	var args = {};

	if ($(endpoint).find('.parameters')) {
		args = $(endpoint).find('tr').toArray().map(function(element) {
			return {
				// to deal with "uh / X-Mod ..."
				paramName:
					$($(element).find('th')).text().split(' ')[0],
				paramDesc:
					$($(element).find('td')).text().replace(/\n$/, '')
			};
		}).reduce(function(prev, curr) {
			prev[curr.paramName] = {
				describe: curr.paramDesc
			};
			return prev;
		}, {});
	}

	return args;
}

function getEndpointMethod($, endpoint) {
	return $('.method', $(endpoint)).text().trim();
}

function getEndpointPaths($, endpoint) {
	// clone so we're not modifying the actual endpoint
	var $endpoint = $(endpoint).clone();

	// remove the following from the h3 tags to get a proper path
	$('.extensions', $endpoint).remove();
	$('.method', $endpoint).remove();
	$('.oauth-scope-list', $endpoint).remove();

	var $h3 = $('h3', $endpoint)
	, placeholders = $('.placeholder', $h3).toArray().map(function(p) {
		return $(p).text();
	})
	, rawPath = $h3.text().trim()
	, paths = [];

	// If we have brackets to handle, remove them
	if (rawPath.indexOf('[') !== -1 && rawPath.indexOf(']') !== -1) {
		var noBracketPath = rawPath
			.replace(/\[.*\]/g, '') // remove anything in brackets
			.replace(/[^\w\/\.]/g, ''); // remove anything else

		placeholders.forEach(function(p) {
			noBracketPath = noBracketPath.replace(p, '$' + p);
		});

		paths.push(noBracketPath);
	}

	var fullPath = rawPath.replace(/[^\w\/\.]/g, '');

	placeholders.forEach(function(p) {
		fullPath = fullPath.replace(p, '$' + p);
	});

	paths.push(fullPath);

	return paths;
}

function getDetails(details) {

	var ret = {};

	if (!details.path || !details.url) {
		throw new Error('missing url');
	}

	ret.path = details.path;
	ret.url = details.url;
	ret.oauth = details.oauth ||  [];
	ret.extensions = details.extensions ||  [];
	ret.method = details.method ||  'GET';
	ret.describe = details.describe ||  '';
	ret.args = details.args ||  {};

	return ret;
}

function getEndpointDetails($, endpoint) {
	var method = getEndpointMethod($, endpoint)
	, paths = getEndpointPaths($, endpoint)
	, oauth = getEndpointOauth($, endpoint);

	return paths.map(function(path) {
		return getDetails({
			oauth: getEndpointOauth($, endpoint),
			extensions: getEndpointExtensions($, endpoint),
			method: method,
			path: path,
			url: getEndpointUrl(method, path, oauth.length > 0),
			describe: getEndpointDescription($, endpoint),
			args: getEndpointArgs($, endpoint)
		});
	});
}

function setNodeValue(currentNode, value, path, index) {
	index = index || 0;

	// If the path does not start with api, we can attach our special
	// xml/json endpoints that make non-api calls return xml/json
	if ( ! /api|captcha|by_id|message/.test(path[0])) {
		addAdditionalType('json');
		addAdditionalType('xml');
	}

	function addAdditionalType(type) {
		if (typeof currentNode[type] !== 'undefined') { return; }

		var currentPath = (
			'/' + path
			.slice(0, index)
			.join('/') + '/.' + type).replace('//', '/')
		, url = getEndpointUrl('GET', currentPath, false);

		currentNode[type] = getDetails({ url: url, path: currentPath });
	}

	var itemInPath = path[index];

	if (index >= path.length - 1) {
		// delete currentNode[itemInPath];
		currentNode[itemInPath] = value;
		return;
	}

	if (typeof currentNode[itemInPath] === 'undefined') {
		currentNode[itemInPath] = {};
	}

	return setNodeValue(currentNode[itemInPath], value, path, ++index);
}

function getEndpoints($) {
	var endpoints = {};

	$('.endpoint').toArray().forEach(function(endpoint) {
		var details = getEndpointDetails($, endpoint);
		details.forEach(function(detail) {
			console.log(detail.path); void('debug');
			var pathSections = detail.path.split('/').slice(1);
			setNodeValue(endpoints, detail, pathSections);
		});
	});

	return endpoints;
}

function getRedditHtml() {
	var apiHtml = when.defer()
	, site = 'http://www.reddit.com/dev/api';
	request(site, function(error, response, body) {
		return error ? apiHtml.reject(error) : apiHtml.resolve(body);
	});
	return apiHtml.promise;
}

exports.buildApi = function() {
	return getRedditHtml().then(function(html) {
		var $ = cheerio.load(html);
		return getEndpoints($);
	});
};

// @TODO test
exports.buildJsonApi = function(minify) {
	return exports.buildApi().then(function(data) {
		var json = minify
			? JSON.stringify(data)
			: JSON.stringify(data, null, 4);
		return json;
	});
};

// @TODO test
function getTemplateString(template, data) {
	var defer = when.defer()
	, stream = mu.compileAndRender(template, data)
	, out = '';

	stream.on('data', function(chnk) { out += chnk.toString(); });
	stream.on('end', function() { return defer.resolve(out); });
	stream.on('error', defer.reject);

	return defer.promise;
}

// @TODO test
exports.buildNodeApi = function() {
	return exports.buildApi().then(function(data) {
		var template =
			path.join(__dirname, 'templates', 'api_node.mu.js');

		return getTemplateString(template, {
			data : JSON.stringify(data)
		});
	});
};

// @TODO test
exports.buildAmdApi = function() {
	return exports.buildApi().then(function(data) {
		var template =
			path.join(__dirname, 'templates', 'api_amd.mu.js');

		return getTemplateString(template, {
			data : JSON.stringify(data)
		});
	});
};

// expose private functions for testing
exports._test = {
	getEndpointOauth: getEndpointOauth,
	getEndpointExtensions: getEndpointExtensions,
	getEndpointUrl: getEndpointUrl,
	getEndpointDescription: getEndpointDescription,
	getEndpointArgs: getEndpointArgs,
	getEndpointMethod: getEndpointMethod,
	getEndpointPaths: getEndpointPaths,
	getEndpointDetails: getEndpointDetails,
	setNodeValue: setNodeValue,
	getEndpoints: getEndpoints,
	getRedditHtml: getRedditHtml,
};

require('main')(module)
.usage('./buildApi [flags] [<outFile>]',
	'',
	'If no file is provided, it will output to stdout')
.flags({
	help: { alias: 'h' },
	minify: { alias: 'm', boolean: true, describe: 'minify output' },
	buildfor: {
		alias: 'b',
		default: 'json',
		describe: 'build for a specific language / library'
	}
})
.run(function($) {

	if ($('help')) { $.cout($.help).exit(); }

	var build;

	switch ($('buildfor')) {
		case 'json':
			build = exports.buildJsonApi($('minify'));
			break;
		case 'node':
			build = exports.buildNodeApi();
			break;
		case 'amd':
			build = exports.buildAmdApi();
			break;
		default:
			build = when.reject(new Error(
				'Invalid "build for" provided'));
	}


	build.then(function(output) {
		return $(0) ? $.write($(0), output) : $.cout(output);
	})
	.otherwise(function(error) {
		$.cerr(error.stack || error).exit(1);
	});
});
